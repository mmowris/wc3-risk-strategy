"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformAssignmentStatement = exports.transformAssignmentExpression = exports.transformAssignment = exports.transformAssignmentLeftHandSideExpression = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const utils_1 = require("../../../utils");
const assignment_validation_1 = require("../../utils/assignment-validation");
const export_1 = require("../../utils/export");
const lua_ast_1 = require("../../utils/lua-ast");
const lualib_1 = require("../../utils/lualib");
const typescript_1 = require("../../utils/typescript");
const access_1 = require("../access");
const destructuring_assignments_1 = require("./destructuring-assignments");
const multi_1 = require("../language-extensions/multi");
const scope_1 = require("../../utils/scope");
const transform_1 = require("../../utils/transform");
const diagnostics_1 = require("../../utils/diagnostics");
function transformAssignmentLeftHandSideExpression(context, node) {
    const symbol = context.checker.getSymbolAtLocation(node);
    const left = context.transformExpression(node);
    return lua.isIdentifier(left) && symbol && export_1.isSymbolExported(context, symbol)
        ? export_1.createExportedIdentifier(context, left)
        : utils_1.cast(left, lua.isAssignmentLeftHandSideExpression);
}
exports.transformAssignmentLeftHandSideExpression = transformAssignmentLeftHandSideExpression;
function transformAssignment(context, 
// TODO: Change type to ts.LeftHandSideExpression?
lhs, right, parent) {
    if (ts.isOptionalChain(lhs)) {
        context.diagnostics.push(diagnostics_1.notAllowedOptionalAssignment(lhs));
        return [];
    }
    if (destructuring_assignments_1.isArrayLength(context, lhs)) {
        const arrayLengthAssignment = lua.createExpressionStatement(lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.ArraySetLength, parent, context.transformExpression(lhs.expression), right));
        return [arrayLengthAssignment];
    }
    const symbol = ts.isShorthandPropertyAssignment(lhs.parent)
        ? context.checker.getShorthandAssignmentValueSymbol(lhs.parent)
        : context.checker.getSymbolAtLocation(lhs);
    const dependentSymbols = symbol ? export_1.getDependenciesOfSymbol(context, symbol) : [];
    const left = transformAssignmentLeftHandSideExpression(context, lhs);
    const rootAssignment = lua.createAssignmentStatement(left, right, lhs.parent);
    return [
        rootAssignment,
        ...dependentSymbols.map(symbol => {
            const [left] = rootAssignment.left;
            const identifierToAssign = export_1.createExportedIdentifier(context, lua.createIdentifier(symbol.name));
            return lua.createAssignmentStatement(identifierToAssign, left);
        }),
    ];
}
exports.transformAssignment = transformAssignment;
function transformDestructuredAssignmentExpression(context, expression) {
    const rootIdentifier = lua.createAnonymousIdentifier(expression.left);
    let right = context.transformExpression(expression.right);
    if (multi_1.isMultiReturnCall(context, expression.right)) {
        right = lua_ast_1.wrapInTable(right);
    }
    const statements = [
        lua.createVariableDeclarationStatement(rootIdentifier, right),
        ...destructuring_assignments_1.transformDestructuringAssignment(context, expression, rootIdentifier),
    ];
    return { statements, result: rootIdentifier };
}
function transformAssignmentExpression(context, expression) {
    // Validate assignment
    const rightType = context.checker.getTypeAtLocation(expression.right);
    const leftType = context.checker.getTypeAtLocation(expression.left);
    assignment_validation_1.validateAssignment(context, expression.right, rightType, leftType);
    if (destructuring_assignments_1.isArrayLength(context, expression.left)) {
        // array.length = x
        return lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.ArraySetLength, expression, context.transformExpression(expression.left.expression), context.transformExpression(expression.right));
    }
    if (typescript_1.isDestructuringAssignment(expression)) {
        return transform_1.transformToImmediatelyInvokedFunctionExpression(context, () => transformDestructuredAssignmentExpression(context, expression), expression);
    }
    if (ts.isPropertyAccessExpression(expression.left) || ts.isElementAccessExpression(expression.left)) {
        // Left is property/element access: cache result while maintaining order of evaluation
        // (function(o, i, v) o[i] = v; return v end)(${objExpression}, ${indexExpression}, ${right})
        const objParameter = lua.createIdentifier("o");
        const indexParameter = lua.createIdentifier("i");
        const valueParameter = lua.createIdentifier("v");
        const indexStatement = lua.createTableIndexExpression(objParameter, indexParameter);
        const statements = [
            lua.createAssignmentStatement(indexStatement, valueParameter),
            lua.createReturnStatement([valueParameter]),
        ];
        const iife = lua.createFunctionExpression(lua.createBlock(statements), [
            objParameter,
            indexParameter,
            valueParameter,
        ]);
        scope_1.pushScope(context, scope_1.ScopeType.Function);
        const objExpression = context.transformExpression(expression.left.expression);
        let indexExpression;
        if (ts.isPropertyAccessExpression(expression.left)) {
            // Property access
            indexExpression = lua.createStringLiteral(expression.left.name.text);
        }
        else {
            // Element access
            indexExpression = access_1.transformElementAccessArgument(context, expression.left);
        }
        const args = [objExpression, indexExpression, context.transformExpression(expression.right)];
        scope_1.popScope(context);
        return lua.createCallExpression(iife, args, expression);
    }
    else {
        return transform_1.transformToImmediatelyInvokedFunctionExpression(context, () => {
            // Simple assignment
            // (function() ${left} = ${right}; return ${left} end)()
            const left = context.transformExpression(expression.left);
            const right = context.transformExpression(expression.right);
            const statements = transformAssignment(context, expression.left, right);
            return { statements, result: left };
        }, expression);
    }
}
exports.transformAssignmentExpression = transformAssignmentExpression;
const canBeTransformedToLuaAssignmentStatement = (context, node) => ts.isArrayLiteralExpression(node.left) &&
    node.left.elements.every(element => {
        if (destructuring_assignments_1.isArrayLength(context, element)) {
            return false;
        }
        if (ts.isPropertyAccessExpression(element) || ts.isElementAccessExpression(element)) {
            return true;
        }
        if (ts.isIdentifier(element)) {
            const symbol = context.checker.getSymbolAtLocation(element);
            if (symbol) {
                const aliases = export_1.getDependenciesOfSymbol(context, symbol);
                return aliases.length === 0;
            }
        }
    });
function transformAssignmentStatement(context, expression) {
    // Validate assignment
    const rightType = context.checker.getTypeAtLocation(expression.right);
    const leftType = context.checker.getTypeAtLocation(expression.left);
    assignment_validation_1.validateAssignment(context, expression.right, rightType, leftType);
    if (typescript_1.isDestructuringAssignment(expression)) {
        if (canBeTransformedToLuaAssignmentStatement(context, expression)) {
            const rightType = context.checker.getTypeAtLocation(expression.right);
            let right = context.transformExpression(expression.right);
            if (ts.isArrayLiteralExpression(expression.right)) {
                right = expression.right.elements.map(e => context.transformExpression(e));
            }
            else if (!multi_1.isMultiReturnCall(context, expression.right) && typescript_1.isArrayType(context, rightType)) {
                right = lua_ast_1.createUnpackCall(context, right, expression.right);
            }
            const left = expression.left.elements.map(e => transformAssignmentLeftHandSideExpression(context, e));
            return [lua.createAssignmentStatement(left, right, expression)];
        }
        let right = context.transformExpression(expression.right);
        if (multi_1.isMultiReturnCall(context, expression.right)) {
            right = lua_ast_1.wrapInTable(right);
        }
        const rootIdentifier = lua.createAnonymousIdentifier(expression.left);
        return [
            lua.createVariableDeclarationStatement(rootIdentifier, right),
            ...destructuring_assignments_1.transformDestructuringAssignment(context, expression, rootIdentifier),
        ];
    }
    else {
        return transformAssignment(context, expression.left, context.transformExpression(expression.right));
    }
}
exports.transformAssignmentStatement = transformAssignmentStatement;
//# sourceMappingURL=assignments.js.map