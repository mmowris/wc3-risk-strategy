"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSuperExpression = exports.transformClassAsExpression = exports.transformThisExpression = exports.transformClassDeclaration = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const utils_1 = require("../../../utils");
const annotations_1 = require("../../utils/annotations");
const diagnostics_1 = require("../../utils/diagnostics");
const export_1 = require("../../utils/export");
const lua_ast_1 = require("../../utils/lua-ast");
const safe_names_1 = require("../../utils/safe-names");
const transform_1 = require("../../utils/transform");
const typescript_1 = require("../../utils/typescript");
const identifier_1 = require("../identifier");
const decorators_1 = require("./decorators");
const accessors_1 = require("./members/accessors");
const constructor_1 = require("./members/constructor");
const fields_1 = require("./members/fields");
const method_1 = require("./members/method");
const new_1 = require("./new");
const setup_1 = require("./setup");
const utils_2 = require("./utils");
const transformClassDeclaration = (declaration, context) => {
    // If declaration is a default export, transform to export variable assignment instead
    if (export_1.hasDefaultExportModifier(declaration)) {
        const left = export_1.createExportedIdentifier(context, export_1.createDefaultExportIdentifier(declaration));
        const right = transformClassAsExpression(declaration, context);
        return [lua.createAssignmentStatement(left, right, declaration)];
    }
    const { statements } = transformClassLikeDeclaration(declaration, context);
    return statements;
};
exports.transformClassDeclaration = transformClassDeclaration;
const transformThisExpression = node => lua_ast_1.createSelfIdentifier(node);
exports.transformThisExpression = transformThisExpression;
function transformClassAsExpression(expression, context) {
    return transform_1.transformToImmediatelyInvokedFunctionExpression(context, () => {
        const { statements, name } = transformClassLikeDeclaration(expression, context);
        return { statements: lua_ast_1.unwrapVisitorResult(statements), result: name };
    }, expression);
}
exports.transformClassAsExpression = transformClassAsExpression;
const classSuperInfos = new WeakMap();
function transformClassLikeDeclaration(classDeclaration, context, nameOverride) {
    let className;
    if (nameOverride !== undefined) {
        className = nameOverride;
    }
    else if (classDeclaration.name !== undefined) {
        className = identifier_1.transformIdentifier(context, classDeclaration.name);
    }
    else {
        // TypeScript error
        className = lua.createAnonymousIdentifier();
    }
    const annotations = annotations_1.getTypeAnnotations(context.checker.getTypeAtLocation(classDeclaration));
    if (annotations.has(annotations_1.AnnotationKind.Extension)) {
        context.diagnostics.push(diagnostics_1.annotationRemoved(classDeclaration, annotations_1.AnnotationKind.Extension));
    }
    if (annotations.has(annotations_1.AnnotationKind.MetaExtension)) {
        context.diagnostics.push(diagnostics_1.annotationRemoved(classDeclaration, annotations_1.AnnotationKind.MetaExtension));
    }
    // Get type that is extended
    const extendedTypeNode = utils_2.getExtendedNode(context, classDeclaration);
    const extendedType = utils_2.getExtendedType(context, classDeclaration);
    const superInfo = utils_1.getOrUpdate(classSuperInfos, context, () => []);
    superInfo.push({ className, extendedTypeNode });
    if (extendedType) {
        new_1.checkForLuaLibType(context, extendedType);
    }
    // You cannot extend LuaTable classes
    if (extendedType) {
        const annotations = annotations_1.getTypeAnnotations(extendedType);
        if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
            context.diagnostics.push(diagnostics_1.luaTableCannotBeExtended(extendedTypeNode));
        }
    }
    if (annotations.has(annotations_1.AnnotationKind.LuaTable) && !typescript_1.isAmbientNode(classDeclaration)) {
        context.diagnostics.push(diagnostics_1.luaTableMustBeAmbient(classDeclaration));
    }
    // Get all properties with value
    const properties = classDeclaration.members.filter(ts.isPropertyDeclaration).filter(member => member.initializer);
    // Divide properties into static and non-static
    const instanceFields = properties.filter(prop => !utils_2.isStaticNode(prop));
    const result = [];
    let localClassName;
    if (safe_names_1.isUnsafeName(className.text)) {
        localClassName = lua.createIdentifier(safe_names_1.createSafeName(className.text), undefined, className.symbolId, className.text);
        lua.setNodePosition(localClassName, className);
    }
    else {
        localClassName = className;
    }
    result.push(...setup_1.createClassSetup(context, classDeclaration, className, localClassName, extendedType));
    // Find first constructor with body
    const constructor = classDeclaration.members.find((n) => ts.isConstructorDeclaration(n) && n.body !== undefined);
    if (constructor) {
        // Add constructor plus initialization of instance fields
        const constructorResult = constructor_1.transformConstructorDeclaration(context, constructor, localClassName, instanceFields, classDeclaration);
        if (constructorResult)
            result.push(constructorResult);
    }
    else if (!extendedType) {
        // Generate a constructor if none was defined in a base class
        const constructorResult = constructor_1.transformConstructorDeclaration(context, ts.factory.createConstructorDeclaration([], [], [], ts.factory.createBlock([], true)), localClassName, instanceFields, classDeclaration);
        if (constructorResult)
            result.push(constructorResult);
    }
    else if (instanceFields.length > 0) {
        // Generate a constructor if none was defined in a class with instance fields that need initialization
        // localClassName.prototype.____constructor = function(self, ...)
        //     baseClassName.prototype.____constructor(self, ...)
        //     ...
        const constructorBody = fields_1.transformClassInstanceFields(context, instanceFields);
        const superCall = lua.createExpressionStatement(lua.createCallExpression(lua.createTableIndexExpression(context.transformExpression(ts.factory.createSuper()), lua.createStringLiteral("____constructor")), [lua_ast_1.createSelfIdentifier(), lua.createDotsLiteral()]));
        constructorBody.unshift(superCall);
        const constructorFunction = lua.createFunctionExpression(lua.createBlock(constructorBody), [lua_ast_1.createSelfIdentifier()], lua.createDotsLiteral(), lua.FunctionExpressionFlags.Declaration);
        result.push(lua.createAssignmentStatement(constructor_1.createConstructorName(localClassName), constructorFunction, classDeclaration));
    }
    // Transform accessors
    for (const member of classDeclaration.members) {
        if (!ts.isAccessor(member))
            continue;
        const accessors = context.resolver.getAllAccessorDeclarations(member);
        if (accessors.firstAccessor !== member)
            continue;
        const accessorsResult = accessors_1.transformAccessorDeclarations(context, accessors, localClassName);
        if (accessorsResult) {
            result.push(accessorsResult);
        }
    }
    const decorationStatements = [];
    for (const member of classDeclaration.members) {
        if (ts.isAccessor(member)) {
            const expression = fields_1.createPropertyDecoratingExpression(context, member, localClassName);
            if (expression)
                decorationStatements.push(lua.createExpressionStatement(expression));
        }
        else if (ts.isMethodDeclaration(member)) {
            const statement = method_1.transformMethodDeclaration(context, member, localClassName);
            if (statement)
                result.push(statement);
            if (member.body) {
                const statement = method_1.createMethodDecoratingExpression(context, member, localClassName);
                if (statement)
                    decorationStatements.push(statement);
            }
        }
        else if (ts.isPropertyDeclaration(member)) {
            if (utils_2.isStaticNode(member)) {
                const statement = fields_1.transformStaticPropertyDeclaration(context, member, localClassName);
                if (statement)
                    decorationStatements.push(statement);
            }
            const expression = fields_1.createPropertyDecoratingExpression(context, member, localClassName);
            if (expression)
                decorationStatements.push(lua.createExpressionStatement(expression));
        }
    }
    result.push(...decorationStatements);
    // Decorate the class
    if (classDeclaration.decorators) {
        const decoratingExpression = decorators_1.createDecoratingExpression(context, classDeclaration.kind, classDeclaration.decorators.map(d => decorators_1.transformDecoratorExpression(context, d)), localClassName);
        const decoratingStatement = lua.createAssignmentStatement(localClassName, decoratingExpression);
        result.push(decoratingStatement);
    }
    superInfo.pop();
    return { statements: result, name: className };
}
const transformSuperExpression = (expression, context) => {
    const superInfos = utils_1.getOrUpdate(classSuperInfos, context, () => []);
    const superInfo = superInfos[superInfos.length - 1];
    if (!superInfo)
        return lua.createAnonymousIdentifier(expression);
    const { className, extendedTypeNode } = superInfo;
    // Using `super` without extended type node is a TypeScript error
    const extendsExpression = extendedTypeNode === null || extendedTypeNode === void 0 ? void 0 : extendedTypeNode.expression;
    let baseClassName;
    if (extendsExpression && ts.isIdentifier(extendsExpression)) {
        const symbol = context.checker.getSymbolAtLocation(extendsExpression);
        if (symbol && !export_1.isSymbolExported(context, symbol)) {
            // Use "baseClassName" if base is a simple identifier
            baseClassName = identifier_1.transformIdentifier(context, extendsExpression);
        }
    }
    if (!baseClassName) {
        // Use "className.____super" if the base is not a simple identifier
        baseClassName = lua.createTableIndexExpression(className, lua.createStringLiteral("____super"), expression);
    }
    return lua.createTableIndexExpression(baseClassName, lua.createStringLiteral("prototype"));
};
exports.transformSuperExpression = transformSuperExpression;
//# sourceMappingURL=index.js.map