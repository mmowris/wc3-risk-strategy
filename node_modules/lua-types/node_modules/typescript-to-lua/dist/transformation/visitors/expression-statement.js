"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformExpressionStatement = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const binary_expression_1 = require("./binary-expression");
const table_1 = require("./language-extensions/table");
const lua_table_1 = require("./lua-table");
const unary_expression_1 = require("./unary-expression");
const transformExpressionStatement = (node, context) => {
    const luaTableResult = lua_table_1.transformLuaTableExpressionStatement(context, node);
    if (luaTableResult) {
        return luaTableResult;
    }
    if (ts.isCallExpression(node.expression) && table_1.isTableDeleteCall(context, node.expression)) {
        return table_1.transformTableDeleteExpression(context, node.expression);
    }
    if (ts.isCallExpression(node.expression) && table_1.isTableSetCall(context, node.expression)) {
        return table_1.transformTableSetExpression(context, node.expression);
    }
    const unaryExpressionResult = unary_expression_1.transformUnaryExpressionStatement(context, node);
    if (unaryExpressionResult) {
        return unaryExpressionResult;
    }
    const binaryExpressionResult = binary_expression_1.transformBinaryExpressionStatement(context, node);
    if (binaryExpressionResult) {
        return binaryExpressionResult;
    }
    const expression = ts.isExpressionStatement(node) ? node.expression : node;
    const result = context.transformExpression(expression);
    return lua.isCallExpression(result) || lua.isMethodCallExpression(result)
        ? lua.createExpressionStatement(result)
        : // Assign expression statements to dummy to make sure they're legal Lua
            lua.createVariableDeclarationStatement(lua.createAnonymousIdentifier(), result);
};
exports.transformExpressionStatement = transformExpressionStatement;
//# sourceMappingURL=expression-statement.js.map